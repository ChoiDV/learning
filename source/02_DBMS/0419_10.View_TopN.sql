-- [X] VIEW, INLINE VIEW, TOP-N 구문
-- 1. VIEW : 가상의 테이블 (1) 단순뷰 (2) 복합뷰
-- 행과 컬럼으로 구성된 가상 테이블
-- 이미 존재하고 있는 테이블에 제한적으로 접근하도록 하기 위함

-- (1) 단순뷰 : 하나의 테이블로 구성한 뷰
-- EMPv0 이라는 VIEW 생성 또는 수정 = EMP테이블 일부 필드를 갖는 가상의 테이블
SELECT * FROM USER_VIEWS; -- 데이터 딕셔너리 뷰 확인

CREATE OR REPLACE VIEW EMPv0 
    AS SELECT EMPNO, ENAME, JOB, MGR, HIREDATE, DEPTNO FROM EMP; -- DDL을 수행하면 데이터 딕셔너리 자동 수정

SELECT * FROM EMPv0; -- 가상의 테이블
INSERT INTO EMPv0 VALUES (1111,'홍','ITMANAGER',7369,SYSDATE,40);
SELECT * FROM EMP;
UPDATE EMPv0 SET JOB='MANAGER' WHERE EMPNO=1111; -- 뷰 UPDATE하면 EMP테이블도 UPDATE됨
DELETE FROM EMPv0 WHERE EMPNO=1111; -- 뷰 DELETE하면 EMP테이블도 DELETE 됨
SELECT * FROM EMPv0;
SELECT * FROM EMP;

-- EMPv0이라는 VIEW : EMP테이블의 30번 부서행만 
CREATE OR REPLACE VIEW EMPv0 
    AS SELECT * FROM EMP WHERE DEPTNO=30;
SELECT * FROM EMPv0;
DESC EMPv0;
INSERT INTO EMPv0 VALUES (1111,'홍',NULL,NULL,SYSDATE,9000,900,30); -- 30번 부서 INSERT
SELECT * FROM EMPv0;
SELECT * FROM EMP;
-- 40번 부서 INSERT 는 가능하나 EMPv0에서는 보이지 않음. EMPv0을 30번부서만 보이게 해놔서
INSERT INTO EMPv0 VALUES (2222,'김',NULL,NULL,SYSDATE,8000,800,40);
SELECT * FROM EMPv0;
SELECT * FROM EMP;
DELETE FROM EMPv0 WHERE EMPNO IN (1111,2222); -- 이러면 1111만 지워짐, 2222는 EMPv0에는 없다고 생각해서 
SELECT * FROM EMPv0;
SELECT * FROM EMP;
DELETE FROM EMP WHERE EMPNO=2222; -- 40번 부서는 EMP에서 삭제

-- EMPv0 뷰 생성: ENAME, JOB, HIREDATE만으로 뷰 생성 NOT NULL필드를 미포함하면 INSERT 불가 
CREATE OR REPLACE VIEW EMPv0
    AS SELECT ENAME, JOB, HIREDATE FROM EMP;
INSERT INTO EMPv0 VALUES ('홍','SALESMAN',SYSDATE);   -- NOT NULL필드를 미포함하면 INSERT 불가
SELECT * FROM EMPv0;
COMMIT;

-- VIEW의 제한 조건 (1) 뷰의 조건 (2) 읽기 전용 
-- WITH CHECK OPTION을 설정한 뷰는 뷰의 조건에 해당되는 데이터만 삽입, 수정, 삭제 가능
-- WITH READ ONLY : 설정한 뷰는 읽기 전용 뷰
CREATE OR REPLACE VIEW EMPv0
    AS SELECT * FROM EMP WHERE DEPTNO= 30
        WITH CHECK OPTION;  -- 30번 부서가 아니면 데이터 삽입,수정,삭제 불가능
INSERT INTO EMPv0 VALUES(1111,'홍',NULL,NULL,SYSDATE,9000,900,30); 
INSERT INTO EMPv0 VALUES(1112,'박',NULL,NULL,SYSDATE,9000,900,40);  -- 30번 부서가 아니라서 불가능
SELECT * FROM EMP;
DELETE FROM EMPv0 WHERE ENAME='SMITH'; -- 20번 부서 SMITH 라서 삭제 안됨
DELETE FROM EMPv0 WHERE EMPNO=1111; -- 30번 부서 DELETE
SELECT * FROM EMP;

-- EMPv0 : 읽기전용 뷰
CREATE OR REPLACE VIEW EMPv0
    AS SELECT EMPNO, ENAME, JOB, MGR, DEPTNO FROM EMP
        WITH READ ONLY;  -- 읽기 전용 뷰
INSERT INTO EMPv0 VALUES (1111,'홍',NULL,NULL,40);  -- 에러 (읽기전용 뷰)


-- (2) 복합뷰 : 2개 이상의 테이블로 구성한 뷰이거나 가상의 필드로 뷰를 만들 경우 DML 문을 제한적으로 사용할수 있음
-- 1. 2개 이상의 테이블
CREATE OR REPLACE VIEW EMPv0
    AS SELECT EMPNO, ENAME, JOB, DNAME, LOC
        FROM EMP E, DEPT D
            WHERE E.DEPTNO = D.DEPTNO;
SELECT * FROM EMPv0;
INSERT INTO EMPv0 VALUES (1111,'HONG','MANAGER','RESEARCH','DALLAS'); -- 복합뷰는 갱신 불가 (INSERT, DELETE 불가 )

-- 2. 가상의 필드로 뷰 생성 : 컬럼에 별칭(영문자로시작, 영문자, 숫자, _ )을 이용하여 뷰 생성 
CREATE OR REPLACE VIEW EMPv0
    AS SELECT EMPNO, ENAME, SAL*12 "YEAR_SAL" FROM EMP     -- 기존의 별칭 선언 방법 
        WHERE DEPTNO=10;

CREATE OR REPLACE VIEW EMPv0 (EMPNO, ENAME, YEAR_SAL)  -- 이렇게 별칭 선언 가능 ( 별칭들만 따로 나열 )
    AS SELECT EMPNO, ENAME, SAL*12 FROM EMP 
        WHERE DEPTNO=10; 
SELECT * FROM EMPv0;
INSERT INTO EMPv0 VALUES (1111,'홍',2400); -- 복합뷰는 갱신 불가

-- ex. 부서번호, 최소급여, 최대 급여, 부서평균 급여를 포함한 뷰 생성 DEPTv1
CREATE OR REPLACE VIEW DEPTv1 (DEPTNO,MINSAL,MAXSAL,AVGSAL)
    AS SELECT DEPTNO, MIN(SAL),MAX(SAL), AVG(SAL)
        FROM EMP
            GROUP BY DEPTNO;
SELECT * FROM DEPTv1;

-- ex. 직책, 부서를 포함한 EMPv0 뷰를 생성
CREATE OR REPLACE VIEW EMPv0
    AS SELECT DISTINCT JOB, DEPTNO
        FROM EMP
            ORDER BY DEPTNO;  -- DISTINCT 포함하면 INSERT 불가 
SELECT * FROM EMPv0;

-- 2. INLINE VIEW : FROM절에 서브쿼리를 INLINE VIEW라 하며, FROM절에 오는 서브쿼리는 VIEW 처럼 작동
-- ex. 급여가 2000을 초과하는 사원의 평균 급여
SELECT AVG(SAL) FROM EMP WHERE SAL > 2000;

SELECT AVG(SAL) FROM (SELECT SAL FROM EMP WHERE SAL> 2000);  -- FROM절에 서브쿼리를 이용. 잠깐 뷰를 생성해줌

-- ex. 부서 평균 월급보다 높은 사원을 사번, 이름 ,급여
SELECT EMPNO, ENAME, SAL
    FROM EMP E
        WHERE SAL > (SELECT AVG(SAL) FROM EMP WHERE DEPTNO=E.DEPTNO); --  서브쿼리

--INLINE VIEW
SELECT EMPNO, ENAME, SAL
    FROM EMP E,(SELECT DEPTNO, AVG(SAL) "AVGSAL" FROM EMP GROUP BY DEPTNO) A
        WHERE E.DEPTNO=A.DEPTNO
            AND SAL > AVGSAL;

-- 3. TOP-N 구문 (TOP 1~10등 / TOP 11~20등 / TOP 6~10등 )
-- ★ ROWNUM : FROM절의 테이블로부터 가져온 순서
SELECT ROWNUM, ENAME FROM EMP WHERE DEPTNO=20;
SELECT ROWNUM, ENAME FROM EMP WHERE DEPTNO=20 ORDER BY ENAME;

-- 등수, 이름, SAL (전체행에 대해)
SELECT ROWNUM, ENAME, SAL FROM EMP ORDER BY SAL DESC; -- 얘는 ROWNUM이 등수가 아니고 테이블로부터 가져온 순서

SELECT ROWNUM, ENAME, SAL
    FROM (SELECT * FROM EMP ORDER BY SAL DESC);  -- ROWNUM은 등수 
    
-- 함수를 이용한 RANK 출력 (비추)
SELECT RANK() OVER(ORDER BY SAL DESC) RANK,
    DENSE_RANK() OVER(ORDER BY SAL DESC) DENSE_RANK,
    ROW_NUMBER() OVER(ORDER BY SAL DESC) ROW_NUMBER,
    ENAME, SAL FROM EMP;

-- SAL기준으로 1~5등
SELECT ROWNUM, ENAME, SAL 
    FROM (SELECT ENAME, SAL FROM EMP ORDER BY SAL DESC)
    WHERE ROWNUM <=5;

-- SAL 기준으로 6~10
SELECT ROWNUM, ENAME, SAL
    FROM (SELECT ENAME, SAL FROM EMP ORDER BY SAL DESC)
        WHERE ROWNUM BETWEEN 6 AND 10; -- 결과가 한행도 안나옴


-- ★ TOP - N 구문 1단계
SELECT ROWNUM "RN", ENAME, SAL
    FROM (SELECT ENAME, SAL FROM EMP ORDER BY SAL DESC);
-- ★ TOP - N 구문 2단계 (완성된 TOP-N구문)
SELECT ROWNUM, RN, ENAME, SAL
    FROM (SELECT ROWNUM "RN", ENAME, SAL FROM (SELECT ENAME, SAL FROM EMP ORDER BY SAL DESC)) A
        WHERE RN BETWEEN 6 AND 10;  -- BETWEEN 숫자만 바꾸면 등수 바꿀수 있음
        
-- 이름을 알파벳 순서대로 정렬해서 6~10번째까지 출력(등수, 이름, 사번, JOB, MGR, HIREDATE)
SELECT RN, ENAME, EMPNO, JOB, MGR, HIREDATE
    FROM (SELECT ROWNUM "RN",ENAME, EMPNO, JOB, MGR, HIREDATE FROM (SELECT * FROM EMP ORDER BY ENAME) ) A
        WHERE RN BETWEEN 6 AND 10;
        
-- ★ 연습문제
-- 1. 부서명과 사원명을 출력하는 용도의 뷰, DNAME_ENAME_VU 를 작성하시오
CREATE OR REPLACE VIEW DNAME_ENAME_VU
    AS SELECT DNAME, ENAME FROM EMP E, DEPT D
        WHERE E.DEPTNO=D.DEPTNO;
SELECT * FROM DNAME_ENAME_VU;

-- 2. 사원명과 직속상관명을 출력하는 용도의 뷰,  WORKER_MANAGER_VU를 작성하시오
CREATE OR REPLACE VIEW WORKER_MANAGER_VU
    AS SELECT W.ENAME "WORKER", M.ENAME "MANAGER"FROM EMP W, EMP M
        WHERE W.MGR = M.EMPNO;
SELECT * FROM WORKER_MANAGER_VU;

-- 3. 부서별 급여합계 등수를 출력하시오(부서번호, 급여합계, 등수). -- 학생 질문
SELECT DEPTNO, "SUMSAL" ,RN
    FROM (SELECT ROWNUM "RN",DEPTNO, "SUMSAL" FROM 
            (SELECT DEPTNO,SUM(SAL) "SUMSAL" FROM EMP GROUP BY DEPTNO ORDER BY SUMSAL DESC));

            
-- 3-1. 부서별 급여합계 등수가 2~3등인 부서번호, 급여합계, 등수를 출력하시오.
SELECT DEPTNO, SUMSAL, RN
    FROM (SELECT ROWNUM "RN",DEPTNO, "SUMSAL" FROM 
              (SELECT DEPTNO,SUM(SAL) "SUMSAL" FROM EMP GROUP BY DEPTNO ORDER BY SUMSAL DESC))
            WHERE RN IN (2,3);
           
-- 4. 사원테이블에서 사번, 사원명, 입사일을 입사일이 최신에서 오래된 사원 순으로 정렬하시오
SELECT EMPNO, ENAME, HIREDATE
    FROM EMP
        ORDER BY HIREDATE DESC;
-- 5. 사원테이블에서 사번, 사원명, 입사일을 입사일이 최신에서 오래된 사원 5명을 출력하시오
SELECT RN, EMPNO, ENAME, HIREDATE
    FROM (SELECT ROWNUM "RN",EMPNO,ENAME,HIREDATE FROM (SELECT * FROM EMP ORDER BY HIREDATE DESC))
            WHERE RN BETWEEN 1 AND 5;

SELECT EMPNO, ENAME, HIREDATE
    FROM( SELECT EMPNO, ENAME, HIREDATE FROM (SELECT * FROM EMP ORDER BY HIREDATE DESC))
        WHERE ROWNUM <= 5;  -- 이렇게 해도 됨 어차피 정렬된상태에서 가져온 순서를 묻기때문에 이렇게 해도됨
                             -- 대신 6~10 번째 처럼 중간것을 빼오는것은 안됨
            
-- 6. 사원 테이블에서 사번, 사원명, 입사일을 최신부터 오래된 순으로 6번째로 늦은 사원부터 10번째 사원까지 출력
SELECT RN, EMPNO, ENAME, HIREDATE
    FROM (SELECT ROWNUM "RN",EMPNO,ENAME,HIREDATE FROM (SELECT * FROM EMP ORDER BY HIREDATE DESC))
            WHERE RN BETWEEN 6 AND 10;

SELECT EMPNO, ENAME, HIREDATE
    FROM (SELECT ROWNUM "RN",A.* FROM (SELECT * FROM EMP ORDER BY HIREDATE DESC) "A")
            WHERE RN BETWEEN 6 AND 10;   -- 이래도 똑같음